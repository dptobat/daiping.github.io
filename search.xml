<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[php核心技术与开发实践：第一章]]></title>
    <url>%2F2019%2F06%2F03%2Fphp_1%2F</url>
    <content type="text"><![CDATA[1.1.1 对象的“形” 先看一段代码：test.php： &lt;?php class person{ public $name; public $gender; public function say(){ echo $this-&gt;name,&quot;is&quot;,$this-&gt;gender; } } test_main.php: &lt;?php namespace ChapterOne; require_once &quot;./test.php&quot;; $student=new person(); $student-&gt;name=&apos;tom&apos;; $student-&gt;gender=&apos;male&apos;; $student-&gt;say(); $teacher=new person(); $teacher-&gt;name=&apos;kate&apos;; $teacher-&gt;gender=&apos;female&apos;; $teacher-&gt;say(); print_r(array($student));//Array ( [0] =&gt; ChapterOne\person Object ( [name] =&gt; tom [gender] =&gt; male ) ) var_dump($student);//object(ChapterOne\person)#1 (2) { [&quot;name&quot;]=&gt; string(3) &quot;tom&quot; [&quot;gender&quot;]=&gt; string(4) &quot;male&quot; } 对象就是一堆数据，那么就可以存储起来，需要的时候在使用。这就是对象的序列化; 对象的序列化只会把对象属性保存起来；需要的时候反序列化还原； $str=serialize($student); echo $str;//O:17:&quot;ChapterOne\person&quot;:2:{s:4:&quot;name&quot;;s:3:&quot;tom&quot;;s:6:&quot;gender&quot;;s:4:&quot;male&quot;;} file_put_contents(&apos;store.txt&apos;,$str); 在需要的时候反序列化： $str=file_get_contents(&apos;store.txt&apos;); $student=unserialize($str); $student-&gt;say();//tom is male 对象序列化只存储对象的属性；类是由属性和方法组成，而对象则是属性的集合，由同一个类生成的不同对象，拥有各自的不同的属性，但共享了类的代码空间中方法区域的代码； 1.1.2 对象的“本” https://phpinternals.net/docs/zend_value 源码zend_type.h中查看： typedef union _zend_value { zend_long lval;//Long value,整型 double dval;//Double value，浮点型 zend_refcounted *counted;//获取不同类型结构的gc计数 zend_string *str;//Zend String value，string字符串 zend_array *arr;//Zend Array value，数组 zend_object *obj;//Zend Object value，object对象 zend_resource*res;//Zend resource value，资源类型 zend_reference *ref;//Zend reference value，引用类型，通过&amp;$var_name定义的 zend_ast_ref *ast;//Zend AST value,抽象语法树，下面都是内核使用的value zval *zv; //Indirect (see IS_INDIRECT) value,指向另一个zval void *ptr;//Pointer (see IS_PTR) value,指针,通用类型 zend_class_entry *ce;//Class entry value,类 zend_function*func;//Function value,函数 struct { uint32_t w1; uint32_t w2; } ww;//This is only really used on 32bit systems for setting the value of a zval when performing a soft copy. } zend_value; zned_value ，就是php底层的变量类型，zend_object 就是变量中的一个结构；接下来看zend_object结构体定义： struct _zend_object { zend_refcounted_h gc;//引用头部gc计数 uint32_t handle; // TODO: may be removed ??? zend_class_entry *ce;//所属的类结构体指针 const zend_object_handlers *handlers;//默认指向全局变量std_object_handlers,存储着包括操作对象属性等的多个指针函数 HashTable*properties;//存储对象的动态普通属性值 zval properties_table[1];柔性数组，存储对象的普通属性值，初始化的创建，大小为普通属性个数default_properties_count+1 }; 1.1.3 对象和数组 对象转化成数组，数组也能转化成对象，数组的键值对和对象的属性/属性值对十分相似；序列化后： echo serialize([&apos;name&apos;=&gt;&apos;tom&apos;,&apos;gender&apos;=&gt;&apos;male&apos;]);//a:2:{s:4:&quot;name&quot;;s:3:&quot;tom&quot;;s:6:&quot;gender&quot;;s:4:&quot;male&quot;;} echo $serialize($student);//O:17:&quot;ChapterOne\person&quot;:2:{s:4:&quot;name&quot;;s:3:&quot;tom&quot;;s:6:&quot;gender&quot;;s:4:&quot;male&quot;;} 对象和数组的区别在于对象有个指针，指向了它所属的类。 1.1.4 namespace ChapterOne新增一段代码： class family{ public $people; public function __construct($p) { $this-&gt;people=$p; } } $tom=new family($student); echo serialize($tom);//O:17:&quot;ChapterOne\family&quot;:1:{s:6:&quot;people&quot;;O:17:&quot;ChapterOne\person&quot;:2:{s:4:&quot;name&quot;;s:3:&quot;tom&quot;;s:6:&quot;gender&quot;;s:4:&quot;male&quot;;}} 序列化后的对象会附带所属的类名，当一个对象的实例变量引用其他对象时，序列化该对象时也会对引用对象进行序列化； 总结：类是定义一系列属性和操作的模板，而对象则是把属性进行具体化，然后交给类处理；对象就是数据，对象本身不包含方法。但是对象有一个“指针”指向一个类，这个类里可以有方法；方法描述不同属性所导致的不同表现；类和对象是不可分割的，有对象就必定有一个类和其对应，否则这个对象也就成了没有亲人的孩子（特殊情况：有数组进行强制类型转换的object,没有一个类和他对应，此时，）；]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的小问题(持续更新)]]></title>
    <url>%2F2019%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[微信小程序客服消息发中文的时候：直接json_encode会乱码，导致发出去的是乱码文字，可以使用下面的方式： json_encode($send_data,JSON_UNESCAPED_UNICODE)； 在云服务器上没有设置放开端口号的情况下，开启了防火墙，导致ssh端口也无法登录；只能使用浏览器 VNC 方式登录 了；输入账号密码；然后在这边开启；firewall-cmd –zone=public –add-port=1234/tcp –permanent ； firewall-cmd –reload laravel配置多环境文件时,例如.env.development,.env.production；这些，采用nginx来配置时：只有将配置写在类似解析： location ~ [^/].php(/|$) ，.php的时候才有效；配置方法是：fastcgi_param APP_ENV development,这样laravel加载的配置文件就是.env.development ,具体可以看laravel源码知道（Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables中bootstrap里面的checkForSpecificEnvironmentFile方法）；配置在fastcgi_param的参数都可以在$_SERVER查看到；(只适用于laravel,lumen需要加一些代码)Lumen需要修改下源代码：app.php的代码修改为（可能并不一定有用）： try { //判断是不是cli模式： $dpenv=php_sapi_name() == ‘cli’?env(‘APP_ENV’):$_SERVER[‘APP_ENV’]; (new Dotenv\Dotenv(dirname(DIR),’.env.’.$dpenv))-&gt;load(); } catch (Dotenv\Exception\InvalidPathException $e) { // }4，在使用supervisor报错：改变代码，不能及时生效；只能重启队列；应该是缓存了代码；supervisorctl rereaderror: , [Errno 2] No such file or directory: file: /usr/lib64/python2.7/socket.py line: 224 supervisorctl stop lumen-worker:*unix:///tmp/supervisor.sock no such file 解决：重新指定配置文件：supervisord -c ./supervisord.confsupervisorctl restart lumen-worker:*成功，但是：却重新多了很多的队列]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mongo</tag>
        <tag>wechat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swoole要掌握的基础知识]]></title>
    <url>%2F2019%2F04%2F02%2Fswoole_1%2F</url>
    <content type="text"><![CDATA[原文为：https://wiki.swoole.com/wiki/page/487.html学习Swoole需要掌握哪些基础知识 多进程/多线程 了解Linux操作系统进程和线程的概念https://www.zhihu.com/question/21535820/answer/22915780 一、关于进程和线程，首先从定义上理解就有所不同１、进程是什么？是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独 立运行的一段程序。2、线程又是什么？线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。 在运行时，只是暂用一些计数器、寄存器和栈 。 二、他们之间的关系 1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。 2. 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 3. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 4. 处理机分给线程，即真正在处理机上运行的是线程。 5. 线程是指进程内的一个执行单元，也是进程内的可调度实体。 三、从三个角度来剖析二者之间的区别 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行。 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源 了解Linux进程/线程切换调度的基本知识 1.进程切换： 进程切换是当今多任务多用户操作系统所应具有的基本功能。 操作系统为了控制进程的执行，必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换，任务切换或上下文切换，挂起正在 CPU 上执行的进程，与中断时保存现场是有区别的，中断前后是在同一个进程上下文中，只是由用户态转向内核态执行。 进程切换分两步https://blog.csdn.net/xiangwanpeng/article/details/78196539 1.切换页目录以使用新的地址空间 2.切换内核栈和硬件上下文。 对于linux来说，线程和进程的最大区别就在于地址空间。对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的。所以明显是进程切换代价大 线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。 了解进程间通信的基本知识，如管道、UnixSocket、消息队列、共享内存 进程间通信的目的：https://blog.csdn.net/gatieme/article/details/50908749 数据传输一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几M字节之间 共享数据 多个进程想要操作共享数据，一个进程对共享数据 通知事一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。 进程控制有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而对Unix发展做出重大贡献的两大主力AT&amp;T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心）在进程间通信方面的侧重点有所不同。 前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“system V IPC”，通信进程局限在单个计算机内； 后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。 早期UNIX进程间通信 基于System V进程间通信 基于Socket进程间通信 POSIX进程间通信。 UNIX进程间通信方式包括：管道、FIFO、信号。 System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存 POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存。 由于Unix版本的多样性，电子电气工程协会（IEEE）开发了一个独立的Unix标准，这个新的ANSI Unix标准被称为计算机环境的可移植性操作系统界面（PSOIX）。现有大部分Unix和流行版本都是遵循POSIX标准的，而Linux从一开始就遵循POSIX标准； BSD并不是没有涉足单机内的进程间通信（socket本身就可以用于单机内的进程间通信）。事实上，很多Unix版本的单机IPC留有BSD的痕迹，如4.4BSD支持的匿名内存映射、4.3+BSD对可靠信号语义的实现等等。 linux使用的进程间通信方式 管道（pipe）,流管道(s_pipe)和有名管道（FIFO） 管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 流管道s_pipe: 去除了第一种限制,可以双向传输. 管道可用于具有亲缘关系进程间的通信，命名管道:name_pipe克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信； 信号量（signal） 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）； 消息队列 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点 共享内存 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。 使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 信号 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 主要作为进程间以及同一进程不同线程之间的同步手段。 套接字（socket) 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信 更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信 更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字 进程间通信各种方式效率比较 类型 无连接 可靠 流控制 记录消息类型 优先级 普通PIPE N Y Y N 流PIPE N Y Y N 命名PIPE(FIFO) N Y Y N 消息队列 N Y Y Y 信号量 N Y Y Y 共享存储 N Y Y Y UNIX流SOCKET N Y Y N UNIX数据包SOCKET Y Y N N 注:无连接: 指无需调用某种形式的OPEN,就有发送消息的能力流控制: 如果系统资源短缺或者不能接收更多消息,则发送进程能进行流量控制 各种通信方式的比较和优缺点 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 如果用户传递的信息较少或是需要通过信号来触发某些行为．前文提到的软中断信号机制不失为一种简捷有效的进程间通信方式． 但若是进程间要求传递的信息量比较大或者进程间存在交换数据的要求，那就需要考虑别的通信方式了。 无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享： 有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错．所以普通用户一般不建议使用。 消息缓冲可以不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便，但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合。 共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。 但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的，因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中，所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。 共享内存块提供了在任意数量的进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。 不幸的是，Linux无法严格保证提供对共享内存块的独占访问，甚至是在您通过使用IPC_PRIVATE创建新的共享内存块的时候也不能保证访问的独占性。 同时，多个使用共享内存块的进程之间必须协调使用同一个键值。 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 如果用户传递的信息较少或是需要通过信号来触发某些行为．前文提到的软中断信号机制不失为一种简捷有效的进程间通信方式． 但若是进程间要求传递的信息量比较大或者进程间存在交换数据的要求，那就需要考虑别的通信方式了。 无名管道简单方便．但局限于单向通信的工作方式．并且只能在创建它的进程及其子孙进程之间实现管道的共享： 有名管道虽然可以提供给任意关系的进程使用．但是由于其长期存在于系统之中，使用不当容易出错．所以普通用户一般不建议使用。 消息缓冲可以不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便，但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合。 共享内存针对消息缓冲的缺点改而利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。 但是共享内存的通信方式是通过将共享的内存缓冲区直接附加到进程的虚拟地址空间中来实现的，因此，这些进程之间的读写操作的同步问题操作系统无法实现。必须由各进程利用其他同步工具解决。另外，由于内存实体存在于计算机系统中，所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。 共享内存块提供了在任意数量的进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。 不幸的是，Linux无法严格保证提供对共享内存块的独占访问，甚至是在您通过使用IPC_PRIVATE创建新的共享内存块的时候也不能保证访问的独占性。 同时，多个使用共享内存块的进程之间必须协调使用同一个键值。 SOCKEThttps://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html 了解SOCKET的基本操作如accept/connect、send/recv、close、listen、bind socket()函数 socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。 正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为： domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口 bind()函数 正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。int bind(int sockfd, const struct sockaddr addr, socklen_t addrlen);函数的三个参数分别为：sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。addr：一个const struct sockaddr 指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是： struct sockaddr_in { sa_family_tsin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */ }; /* Internet address. */ struct in_addr { uint32_t s_addr; /* address in network byte order */ }; ipv6对应的是： struct sockaddr_in6 { sa_family_t sin6_family; /* AF_INET6 */ in_port_t sin6_port; /* port number */ uint32_tsin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_tsin6_scope_id; /* Scope ID (new in 2.4) */ }; struct in6_addr { unsigned char s6_addr[16]; /* IPv6 address */ }; Unix域对应的是： #define UNIX_PATH_MAX108 struct sockaddr_un { sa_family_t sun_family; /* AF_UNIX */ charsun_path[UNIX_PATH_MAX]; /* pathname */ }; addrlen：对应的是地址的长度。通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。 网络字节序与主机字节序主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下： a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。 网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。 所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。 listen()、connect()函数 如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。 int listen(int sockfd, int backlog); int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。 connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。 accept()函数 TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。 int accept(int sockfd, struct sockaddr addr, socklen_t addrlen);accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。 注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。 read()、write()等函数万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组： read()/write() recv()/send() readv()/writev() recvmsg()/sendmsg() recvfrom()/sendto() 我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下： #include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; ssize_t send(int sockfd, const void *buf, size_t len, int flags); ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags); ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。 write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。 其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。 close()函数 在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。 #include &lt;unistd.h&gt; int close(int fd); close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。 注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。 了解SOCKET的接收缓存区、发送缓存区、阻塞/非阻塞、超时等概念 SOCKET的接收缓存区、发送缓存区 socket缓冲区 每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取 这些I/O缓冲区特性可整理如下： I/O缓冲区在每个TCP套接字中单独存在； I/O缓冲区在创建套接字时自动生成； 即使关闭套接字也会继续传送输出缓冲区中遗留的数据； 关闭套接字将丢失输入缓冲区中的数据。 阻塞/非阻塞 阻塞模式 对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时： 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。 直到所有数据被写入缓冲区 write()/send() 才能返回。 当使用 read()/recv() 读取数据时： 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。 这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。TCP套接字默认情况下是阻塞模式 socket阻塞与非阻塞，同步与异步https://blog.csdn.net/hguisu/article/details/7453390 IO复用 了解select/poll/epoll https://www.cnblogs.com/Anker/p/3265058.html select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间 1、select实现 select的调用过程如下所示： （1）使用copy_from_user从用户空间拷贝fd_set到内核空间 （2）注册回调函数__pollwait （3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll） （4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。 （5) __pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。 （6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。 （7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。 （8）把fd_set从内核空间拷贝到用户空间。 总结： select的几大缺点： （1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 （2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大 （3）select支持的文件描述符数量太小了，默认是1024 2 poll实现 poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，其他的都差不多 3、epoll epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。 总结： （1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。 （2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。 了解基于select/epoll实现的事件循环，Reactor模型 Reactor模型https://blog.csdn.net/u013074465/article/details/46276967 了解了解可读事件、可写事件 https://blog.csdn.net/justlinux2010/article/details/7780506 可读事件: 当文件描述符关联的内核读缓冲区可读，则触发可读事件什么是可读呢？ 就是内核缓冲区非空，有数据可以读取 可写事件: 当文件描述符关联的内核写缓冲区可写，则触发可写事件什么是可写呢？就是内核缓冲区不满，有空闲空间可以写入 TCP/IP网络协议 了解TCP/IP协议https://www.cnblogs.com/onepixel/p/7092302.html 互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（英语：TCP/IP Protocol Stack） 。这些协议最早发源于美国国防部（缩写为DoD）的ARPA网项目，因此也被称作DoD模型（DoD Model）[6]。这个协议族由互联网工程任务组负责维护。 TCP/IP提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信进程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。 了解TCP、UDP传输协议 https://zhangjiangxing-gmail-com.iteye.com/blog/646880使用抓包工具测试 TCP： 传输控制协议（英语：Transmission Control Protocol，缩写：TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。 在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。 应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 UDP： 用户数据包协议（英语：User Datagram Protocol，缩写：UDP），又称用户数据包协议，是一个简单的面向数据报的传输层协议。该协议由 David P. Reed 在 1980 年设计且在RFC 768中被规范。 在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验（字段）。 UDP首部字段由4个部分组成，其中两个是可选的。各16bit的来源端口和目的端口用来标记发送和接受的应用进程。因为UDP不需要应答，所以来源端口是可选的，如果来源端口不用，那么置为零。在目的端口后面是长度固定的以字节为单位的长度域，用来指定UDP数据报包括数据部分的长度，长度最小值为8byte。首部剩下地16bit是用来对首部和数据部分一起做校验和（Checksum）的，这部分是可选的，但在实际应用中一般都使用这一功能。 由于缺乏可靠性且属于非连接导向协议，UDP应用一般必须允许一定量的丢包、出错和重复。但有些应用，比如TFTP，如果需要则必须在应用层增加根本的可靠机制。但是绝大多数UDP应用都不需要可靠机制，甚至可能因为引入可靠机制而降低性能。流媒体（流技术）、即时多媒体游戏和IP电话（VoIP）一定就是典型的UDP应用。如果某个应用需要很高的可靠性，那么可以用传输控制协议（TCP协议）来代替UDP。 由于缺乏拥塞控制（congestion control），需要基于网络的机制来减少因失控和高速UDP流量负荷而导致的拥塞崩溃效应。换句话说，因为UDP发送者不能够检测拥塞，所以像使用包队列和丢弃技术的路由器这样的网络基本设备往往就成为降低UDP过大通信量的有效工具。数据报拥塞控制协议（DCCP）设计成通过在诸如流媒体类型的高速率UDP流中，增加主机拥塞控制，来减小这个潜在的问题。 典型网络上的众多使用UDP协议的关键应用一定程度上是相似的。这些应用包括域名系统（DNS）、简单网络管理协议（SNMP）、动态主机配置协议（DHCP）、路由信息协议（RIP）和某些影音流服务等等。]]></content>
      <categories>
        <category>swoole</category>
      </categories>
      <tags>
        <tag>swoole</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
